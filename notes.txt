## GitHub Actions
    GitHub Actions is GitHub’s built-in CI/CD + automation platform. You define workflows (YAML files) that run on events (push, PR, schedule, manual) and perform jobs (build, test, deploy).

GitHub Handles Rest - 
    1. Task in virtual machines
    2. Caching dependencies
    3. Providing reports on the outcomes

GitHub Actions can operate on different OS such as Windows, Linux, and macOS.

## GitHub Actions used for
   1. Building
   2. Unit Testing
   3. Linting
   4. Dockerizing
   5. Security Scanning
   6. Deployment
   7. Tests etc.


## GitHub Actions Trigger Events
    1. branch_protection_rule → Triggers when a branch protection rule is created, edited, or deleted.
    2. check_run → Fires for check run status changes (created, completed, rerequested).
    3. check_suite → Fires when check suites are requested or completed.
    4. create → When a branch or tag is created.
    5. delete → When a branch or tag is deleted.
    6. deployment → When a deployment is created.
    7. deployment_status → When a deployment status changes (e.g., success, failure).
    8. discussion → Fires for GitHub Discussions events (created, edited, answered, etc.).
    9. discussion_comment → When a comment is created, edited, or deleted on a discussion.
    10. fork → When someone forks the repository.
    11. gollum → When a wiki page is created or updated.
    12. issue_comment → When a comment is created, edited, or deleted on an issue or pull request.
    13. issues → When an issue is opened, edited, labeled, assigned, closed, etc.
    14. label → When a label is created, edited, or deleted in the repo.
    15. merge_group → For merge queue events.
    16. milestone → When a milestone is created, closed, opened, or deleted.
    17. page_build → When a GitHub Pages site is built or fails to build.
    18. public → When a repository is made public.
    19. pull_request → When a PR is opened, synchronized, reopened, labeled, closed, etc.
    20. pull_request_review → When a review is submitted, edited, or dismissed on a PR.
    21. pull_request_review_comment → When a review comment is created, edited, or deleted on a PR.
    22. pull_request_target → Similar to pull_request, but runs in the context of the base repo (useful for forks, but with security caveats).
    23. push → When commits are pushed to branches or tags.
    24. registry_package → When a package is published or updated in GitHub Packages.
    25. release → When a release is created, published, updated, or deleted.
    26. repository_dispatch → Custom event you can trigger via API/webhook.
    27. schedule → Runs on a cron schedule you define (e.g., nightly build).
    28. status → When the status of a Git commit changes (e.g., CI passes/fails).
    29. watch → When someone stars the repository.
    30. workflow_call → When another workflow calls this workflow (reusable workflows).
    31. workflow_dispatch → Manual trigger from GitHub UI or API (can take inputs).
    32. workflow_run → When another workflow run completes (success/failure).

## Workflow in GitHub Actions
    A workflow is the automation recipe you define in your repository for GitHub Actions.
    It tells GitHub when to run, what environment to use, and what steps to perform.

    A workflow is made of:
        Events → what triggers it (on:)
        Jobs → groups of steps that run on runners.
        Steps → individual actions or shell commands inside jobs.

    Linux and windows runner hosted on Microsoft Azure platforms
    MacOS runner hosted on Githubs own macOS cloud

    ## Runners → virtual machines or containers where jobs run (hosted by GitHub or self-hosted).
    Types of Runners
    1. GitHub-Hosted Runners
        - Managed by GitHub
        - Automatically updated and maintained
        - Available for Linux, Windows, and macOS. but cannot make system level changes
        - Free tier available with usage limits based on account type (free, pro, team, enterprise)
    2. Self-Hosted Runners
        - Managed by you
        - Can run on your own hardware or cloud instances
        - More control over the environment and software installed
        - Useful for specific requirements (e.g., special hardware, software licenses)
        - Requires maintenance and updates by you


## How to define action versions in workflows
    1. By major version (common, stable)
        uses: actions/checkout@v3
        
    2. By major and minor version (more specific)
        uses: actions/checkout@v3.1

    3. By full semantic version (most specific, exact)
        uses: actions/checkout@v3.1.0

    4. By git tag (specific to a tag)
        uses: actions/checkout@v3.1.0-beta

    5. By git SHA (exact commit, most precise)
        uses: actions/checkout@d3d9446802a44259755d38
        
    6. By branch name (less common, can change)
        uses: actions/checkout@main

    ## uses keyword is used to specify an action to run as part of steps. and it can reference actions from GitHub Marketplace, public repositories, or local actions in your repo.


## IMP NOTE
    1. Any files that are created in VM during workflow execution will get deleted once the workflow run is complete.
    They are not present in repo.
    2. Also you can disable workflow with manually from gitHub -> action -> select workflow -> disable workflow from 3 dots menu

## Multiple jobs
    1. Each Job need to run in its own Virtual machines. They Does not run on same VM.
    2. Bydefault jobs run in parallel and they do not waits for each other. So may be your deployment job run before build job is completed.
    3. To run jobs sequentially use "needs" keyword.
    4. If one job fails then bydefault other jobs will not run.

## Storing workflow data as Artifacts
    1. Artifacts are used to store data generated during a workflow run, such as build outputs, test results, or logs.
    2. Artifacts can be uploaded and downloaded using the actions/upload-artifact and actions/download-artifact actions.
    3. Artifacts are stored for a limited time (default is 90 days) and can be accessed from the workflow run page in GitHub.


## Types of environment variables Types
    1. Step level: Available only within the specific step where they are defined.
    2. Job level: Available to all steps within a specific job.
    3. Workflow level: Available to all jobs and steps within the entire workflow.

    ways to use environment variables
    1. using $VAR_NAME
    2. using ${{ env.VAR_NAME }}
    
## Repository Secrets
    1. Go to repository -> Settings -> Secrets and variables -> Actions -> New repository secret -> Add secret name and value -> Add secret
    2. To use secret in workflow use ${{ secrets.SECRET_NAME }}
    3. Secrets are encrypted emvironmnt variables. They are not visible in workflow logs.

    # Also you can store variables in repository level. Which can be used in any workflow in that repo.
    and accessed using ${{ vars.VAR_NAME }} syntax.

## Concurrency in workflows
    It allows you to run only a single job or workflow at a time for a given concurrency group.
    If a new job or workflow is triggered while another one is still running in the same concurrency group, 
    the new one will be queued or canceled based on the concurrency settings.
    
    We can use it on workflow

    use case -
        Preventing duplicate deployments: If multiple commits are pushed to a branch in quick succession, 
        you might want to ensure that only the latest commit is deployed, canceling any previous deployment jobs that are still running.
    
    1. concurrency: 
        group:  # Unique group name (e.g., branch name)
        cancel-in-progress: true   # Cancel any in-progress runs in the same group
        cancel-in-progress: false   # Queue new runs until the current one finishes


## GitHub kills workflow if it runs for more than 6 hours ( 3600 minutes ).
    Solution - you can use timeOut in 1.workflow level 2.job level 3.step level

## Strategy Matrix Configuration
    It allows you to run a job multiple times with different configurations (e.g., different OS, language versions, etc.) in parallel.
    This is useful for testing your code across multiple environments.

    # While parallel execution if one job fails then bydefault other jobs will not run.

    Example - testing on multiple versions of Node.js and operating systems

    jobs:
      build:
        runs-on: ${{ matrix.os }}
        strategy:
          matrix:
            os: [ubuntu-latest, windows-latest, macos-latest]
            node: [12, 14, 16]
          fail-fast: false  # Continue running all jobs even if one fails
        steps:
          - uses: actions/checkout@v2
          - name: Set up Node.js ${{ matrix.node }}
            uses: actions/setup-node@v2
            with:
              node-version: ${{ matrix.node }}
          - run: npm install
          - run: npm test

## Context
        A context is a way to access information in your workflow.
    Think of it like a data object that holds variables about the workflow run, job, steps, GitHub environment, secrets, etc.

    You use contexts with the ${{ }} expression syntax.
    1. github context
    2. env context
    3. job context
    4. secrets context
    5. steps context
    6. strategy context
    7. secret context
    8. vars context

## Expression
    Expressions are used to evaluate values in workflows.
    They are enclosed in ${{ }} and can include functions, operators, and context references.

    Example - using an expression to check if a branch is main
    if: ${{ github.ref == 'refs/heads/main' }}

    types of expressions
    1. Logical expressions: and, or, not
    2. Comparison expressions: ==, !=, <, >, <=, >=
    3. Mathematical expressions: +, -, *, /, %
    4. String expressions: contains(), startsWith(), endsWith()
    5. Date expressions: format(), fromJson(), toJson()
    6. Array expressions: join(), contains(), length()
    7. Hash expressions: hashFiles()
    8. Conversion expressions: toJson(), fromJson(), toYaml(), fromYaml()
    